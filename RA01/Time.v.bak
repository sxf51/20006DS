//Time module
module Time(input clk, output [5: 0] hours, mins, secs);
    localparam N = 50_000_000;
    localparam BW = $clog2(N);
    wire [BW-1: 0] tick;
	 
    Counter #(.MAX(N-1), .WIDTH(BW), .UP(1'b1))
        divider(.clk(clk), .enable(1'b1), .plus(1'b0), .minus(1'b0), .cnt(tick));
    Counter #(.MAX(59), .WIDTH(6), .UP(1'b1))
        cs(.clk(clk), .enable(tick == 0), .plus(1'b0), .minus(1'b0), .cnt(secs));
	 Counter #(.MAX(59), .WIDTH(6), .UP(1'b1))
        cm(.clk(clk), .enable(secs == 59 && tick == 0), .plus(1'b0), .minus(1'b0), .cnt(mins));
	 Counter #(.MAX(23), .WIDTH(6), .UP(1'b1))
        ch(.clk(clk), .enable(mins == 59 && secs == 59 && tick == 0), .plus(1'b0), .minus(1'b0), .cnt(hours));
endmodule

//Counter module
module Counter
    #(parameter MAX = 1, WIDTH = 1, UP = 1)(
        input clk,
        input enable,
		  input plus,
		  input minus,
        output reg [WIDTH-1 : 0] cnt
    );
    
    initial cnt = 0;
    
    reg [WIDTH-1 : 0] next_cnt;
    
    always @(posedge clk)
        if (enable) cnt <= next_cnt;
        
    always @(*)
		  case({plus, minus})
				00: next_cnt = (cnt == MAX) ? 1'd0 : cnt + UP;
				01: next_cnt = (cnt == 1'd0) ? MAX : cnt - 1'd1;
				10: next_cnt = (cnt == MAX) ? 1'd0 : cnt + 1'd1;
				11: next_cnt = cnt;
				default: next_cnt = cnt;
		  endcase
endmodule